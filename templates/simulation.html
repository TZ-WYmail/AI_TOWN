<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI小镇 - 量子模拟空间</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&display=swap');
        
        * { 
            box-sizing: border-box; 
            margin: 0; 
            padding: 0; 
        }
        
        body { 
            font-family: 'Orbitron', monospace; 
            background: #000;
            color: #00ffff; 
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }
        
        /* 动态背景效果 */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(255, 0, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 20%, rgba(0, 255, 128, 0.1) 0%, transparent 50%);
            z-index: -2;
        }
        
        /* 网格背景 */
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(0, 255, 255, 0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.1) 1px, transparent 1px);
            background-size: 50px 50px;
            z-index: -1;
            animation: grid-move 10s linear infinite;
        }
        
        @keyframes grid-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }
        
        .container { 
            max-width: 1400px; 
            margin: 0 auto; 
            padding: 20px; 
            position: relative;
            z-index: 1;
        }
        
        header { 
            text-align: center; 
            padding: 30px 0; 
            position: relative;
        }
        
        h1 { 
            font-size: 3rem; 
            margin-bottom: 15px; 
            text-transform: uppercase;
            letter-spacing: 3px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff88);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
            animation: glow 2s ease-in-out infinite alternate;
        }
        
        @keyframes glow {
            from { filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.8)); }
            to { filter: drop-shadow(0 0 20px rgba(255, 0, 255, 0.8)); }
        }
        
        .controls { 
            display: flex; 
            justify-content: center; 
            gap: 20px; 
            margin: 30px 0; 
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 30px;
            padding: 10px 20px;
        }
        
        .control-group label {
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 0.9rem;
        }
        
        .control-group input {
            width: 80px;
            padding: 8px;
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px;
            background: rgba(0, 30, 60, 0.8);
            color: #00ffff;
            font-family: 'Orbitron', monospace;
        }
        
        button { 
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            color: #000; 
            border: none; 
            padding: 12px 25px; 
            border-radius: 30px; 
            font-size: 1rem; 
            font-weight: 700; 
            cursor: pointer; 
            transition: all 0.3s ease; 
            box-shadow: 0 4px 20px rgba(0, 255, 255, 0.4);
            text-transform: uppercase;
            letter-spacing: 2px;
            font-family: 'Orbitron', monospace;
            position: relative;
            overflow: hidden;
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover { 
            transform: translateY(-3px); 
            box-shadow: 0 8px 25px rgba(0, 255, 255, 0.6);
        }
        
        button:disabled { 
            opacity: 0.6; 
            cursor: not-allowed; 
            transform: none; 
        }
        
        .stage-container { 
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            height: 600px;
            width: 100%;
            border-radius: 15px; 
            padding: 25px; 
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.2),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }
        
        .stage-container::before {
            content: '';
            position: absolute;
            width:100%;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff88, #00ffff);
            border-radius: 15px;
            z-index: -1;
            opacity: 0.5;
            animation: border-rotate 4s linear infinite;
        }
        
        @keyframes border-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #stage { 
            position: absolute;  /* 改为绝对定位 */
            bottom: 0;           /* 置底 */
            left: 0;             /* 左对齐 */
            right: 0;            /* 右对齐 */
            width: 100%; 
            height: 540px; 
            margin: 0;           /* 移除 auto margin */
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 12px; 
            overflow: hidden; 
            box-shadow: 
                0 0 50px rgba(0, 255, 255, 0.3),
                inset 0 0 30px rgba(0, 0, 0, 0.5);

        }

        
        .agent { 
            position: absolute; 
            width: 56px; 
            height: 56px; 
            border-radius: 50%; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            color: #000; 
            font-weight: 700; 
            transition: all 0.8s linear; 
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.8),
                0 0 40px rgba(0, 255, 255, 0.4);
            z-index: 10;
        }
        
        .bubble { 
            position: absolute; 
            background: rgba(0, 20, 40, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.5);
            color: #00ffff; 
            padding: 10px 15px; 
            border-radius: 10px; 
            max-width: 260px; 
            transform: translateY(-70px); 
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.3),
                inset 0 0 10px rgba(0, 255, 255, 0.1);
            font-size: 0.9rem;
            z-index: 20;
        }
        
        .bubble::after { 
            content: ''; 
            position: absolute; 
            bottom: -10px; 
            left: 20px; 
            border-width: 10px 10px 0; 
            border-style: solid; 
            border-color: rgba(0, 255, 255, 0.5) transparent; 
        }
        
        #info { 
            text-align: center; 
            margin: 20px 0; 
            font-size: 1.2rem;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .data-panel { 
            background: rgba(0, 20, 40, 0.8);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 15px; 
            padding: 25px; 
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.2),
                inset 0 0 20px rgba(0, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .data-panel::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, #00ffff, #ff00ff, #00ff88, #00ffff);
            border-radius: 15px;
            z-index: -1;
            opacity: 0.5;
            animation: border-rotate 4s linear infinite;
        }
        
        .tabs { 
            display: flex; 
            margin-bottom: 25px; 
            border-bottom: 2px solid rgba(0, 255, 255, 0.2);
        }
        
        .tab { 
            padding: 15px 25px; 
            cursor: pointer; 
            border-radius: 10px 10px 0 0; 
            margin-right: 5px; 
            background: rgba(0, 20, 40, 0.6);
            border: 2px solid transparent;
            border-bottom: none;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }
        
        .tab:hover {
            background: rgba(0, 40, 80, 0.8);
            border-color: rgba(0, 255, 255, 0.3);
        }
        
        .tab.active { 
            background: rgba(0, 40, 80, 0.8);
            border-color: rgba(0, 255, 255, 0.5);
            color: #00ffff;
            box-shadow: 0 -5px 15px rgba(0, 255, 255, 0.2);
        }
        
        .tab-content { 
            display: none; 
        }
        
        .tab-content.active { 
            display: block; 
        }
        
        .data-grid { 
            display: grid; 
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); 
            gap: 20px; 
        }
        
        .data-card { 
            background: rgba(0, 30, 60, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 20px; 
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }
        
        .data-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
        }
        
        .data-card h3 { 
            margin-bottom: 15px; 
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .data-card p { 
            margin-bottom: 10px; 
            line-height: 1.6;
            color: rgba(0, 255, 255, 0.9);
        }
        
        .data-card strong {
            color: #00ff88;
        }
        
        .timeline-item { 
            background: rgba(0, 30, 60, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.2);
            padding: 20px; 
            border-radius: 10px; 
            margin-bottom: 20px;
            border-left: 4px solid #00ffff;
            position: relative;
        }
        
        .timeline-item h3 { 
            margin-bottom: 15px; 
            color: #00ffff;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .timeline-item p {
            margin-bottom: 8px;
            color: rgba(0, 255, 255, 0.9);
        }
        
        .timeline-item strong {
            color: #00ff88;
        }
        
        .progress-bar { 
            width: 100%; 
            height: 10px; 
            background: rgba(0, 20, 40, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 5px; 
            margin: 20px 0; 
            overflow: hidden;
            position: relative;
        }
        
        .progress { 
            height: 100%; 
            background: linear-gradient(90deg, #00ffff, #ff00ff, #00ff88);
            width: 0%; 
            transition: width 0.3s ease;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
        }
        
        .back-link { 
            display: inline-block; 
            margin-top: 30px; 
            color: #00ffff; 
            text-decoration: none; 
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            padding: 10px 20px;
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 30px;
            transition: all 0.3s ease;
        }
        
        .back-link:hover { 
            text-decoration: none;
            background: rgba(0, 40, 80, 0.8);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }
        
        @media (max-width: 768px) {
            .data-grid { grid-template-columns: 1fr; }
            h1 { font-size: 2.2rem; }
            .container { padding: 15px; }
            .controls { flex-direction: column; align-items: center; }
        }
        
        /* 扫描线效果 */
        .scanline {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #00ffff, transparent);
            animation: scan 4s linear infinite;
            z-index: 100;
            pointer-events: none;
        }
        
        @keyframes scan {
            0% { transform: translateY(0); }
            100% { transform: translateY(100vh); }
        }
        
        /* 粒子效果 */
        .particle {
            position: absolute;
            width: 2px;
            height: 2px;
            background: #00ffff;
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.8;
        }
        
        .outline-container {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }

        .outline-section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(0, 30, 60, 0.6);
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 8px;
        }

        .events-timeline {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .event-item {
            padding: 10px;
            background: rgba(0, 40, 80, 0.6);
            border-left: 3px solid #00ffff;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .event-item.active {
            background: rgba(0, 60, 120, 0.8);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .step-number {
            color: #00ff88;
            font-weight: bold;
        }

        .event-type {
            color: #ff00ff;
            text-transform: uppercase;
            font-size: 0.8rem;
        }

        .room-info {
            margin-bottom: 10px;
            padding: 10px;
            background: rgba(0, 50, 100, 0.6);
            border-radius: 6px;
        }

        .room-details {
            font-size: 0.9rem;
            color: rgba(0, 255, 255, 0.8);
        }
        
        /* 地图和智能体样式 */
        .room-element {
            transition: all 0.3s ease;
        }

        .room-element:hover {
            background: rgba(0, 80, 160, 0.5);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);
        }

        .path-element {
            transition: all 0.3s ease;
        }

        .agent-status {
            position: absolute;
            bottom: -25px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            color: #00ff88;
            white-space: nowrap;
            background: rgba(0, 20, 40, 0.8);
            padding: 2px 5px;
            border-radius: 3px;
            z-index: 15;
        }
                /* 增强的房间样式 */
        .room-element {
            transition: all 0.3s ease;
            border: 3px solid rgba(0, 255, 255, 0.9) !important;
            background: linear-gradient(135deg, rgba(0, 80, 160, 0.7), rgba(0, 120, 200, 0.5)) !important;
            box-shadow: 
                0 0 20px rgba(0, 255, 255, 0.6),
                inset 0 0 20px rgba(0, 255, 255, 0.2),
                0 0 40px rgba(0, 150, 255, 0.4) !important;
            animation: roomGlow 3s ease-in-out infinite alternate;
        }

        @keyframes roomGlow {
            0% { 
                box-shadow: 
                    0 0 20px rgba(0, 255, 255, 0.6),
                    inset 0 0 20px rgba(0, 255, 255, 0.2),
                    0 0 40px rgba(0, 150, 255, 0.4);
            }
            100% { 
                box-shadow: 
                    0 0 30px rgba(0, 255, 255, 0.9),
                    inset 0 0 30px rgba(0, 255, 255, 0.4),
                    0 0 60px rgba(0, 200, 255, 0.6);
            }
        }

        .room-element:hover {
            background: linear-gradient(135deg, rgba(0, 120, 200, 0.8), rgba(0, 180, 255, 0.6)) !important;
            box-shadow: 
                0 0 30px rgba(0, 255, 255, 0.9),
                inset 0 0 30px rgba(0, 255, 255, 0.4),
                0 0 60px rgba(0, 200, 255, 0.7) !important;
            transform: scale(1.03);
            border-color: rgba(255, 255, 0, 0.9) !important;
        }

        /* 增强的路径样式 */
        .path-element {
            background: linear-gradient(90deg, 
                rgba(255, 100, 0, 0.9) 0%, 
                rgba(255, 200, 0, 0.7) 25%,
                rgba(255, 255, 0, 0.8) 50%,
                rgba(255, 200, 0, 0.7) 75%,
                rgba(255, 100, 0, 0.9) 100%) !important;
            height: 5px !important;
            box-shadow: 
                0 0 15px rgba(255, 200, 0, 0.8),
                0 0 30px rgba(255, 150, 0, 0.6) !important;
            animation: pathPulse 2s ease-in-out infinite;
        }

        @keyframes pathPulse {
            0%, 100% { 
                opacity: 0.8;
                box-shadow: 
                    0 0 15px rgba(255, 200, 0, 0.8),
                    0 0 30px rgba(255, 150, 0, 0.6);
            }
            50% { 
                opacity: 1;
                box-shadow: 
                    0 0 25px rgba(255, 200, 0, 1),
                    0 0 50px rgba(255, 150, 0, 0.8);
            }
        }

        /* 增强的路径端点样式 */
        .path-point {
            background: radial-gradient(circle, rgba(255, 255, 0, 1) 0%, rgba(255, 200, 0, 0.8) 100%) !important;
            box-shadow: 
                0 0 20px rgba(255, 255, 0, 0.9),
                0 0 40px rgba(255, 200, 0, 0.7) !important;
            animation: pointPulse 1.5s ease-in-out infinite;
        }

        @keyframes pointPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 
                    0 0 20px rgba(255, 255, 0, 0.9),
                    0 0 40px rgba(255, 200, 0, 0.7);
            }
            50% { 
                transform: scale(1.3);
                box-shadow: 
                    0 0 30px rgba(255, 255, 0, 1),
                    0 0 60px rgba(255, 200, 0, 0.9);
            }
        }

        /* 平滑的智能体移动 */
        .agent {
            transition: all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) !important;
            box-shadow: 
                0 0 30px currentColor,
                0 0 60px currentColor,
                0 0 90px currentColor !important;
            animation: agentFloat 3s ease-in-out infinite;
        }

        @keyframes agentFloat {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }

        .agent:hover {
            transform: scale(1.2) translateY(-5px);
            z-index: 100;
            transition: all 0.3s ease;
        }

        /* 智能体移动轨迹效果 */
        .agent::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%);
            animation: agentRipple 2s ease-out infinite;
        }

        @keyframes agentRipple {
            0% {
                transform: scale(1);
                opacity: 0.8;
            }
            100% {
                transform: scale(2);
                opacity: 0;
            }
        }
           /* 模态框背景 */
    .modal {
        display: none; /* 默认隐藏 */
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.8);
        animation: fadeIn 0.3s;
    }

    /* 模态框内容 */
    .modal-content {
        background: rgba(0, 20, 40, 0.95);
        border: 2px solid rgba(0, 255, 255, 0.5);
        margin: 10% auto;
        padding: 30px;
        border-radius: 15px;
        width: 60%;
        min-width: 400px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        position: relative;
    }

    /* 关闭按钮 */
    .close-btn {
        color: #aaa;
        position: absolute;
        top: 15px;
        right: 25px;
        font-size: 35px;
        font-weight: bold;
        cursor: pointer;
        transition: color 0.3s;
    }

    .close-btn:hover,
    .close-btn:focus {
        color: #00ffff;
    }

    /* 模态框内信息样式 */
    #modal-agent-body p {
        margin-bottom: 12px;
        line-height: 1.6;
    }
    
    #modal-agent-body strong {
        color: #00ff88;
    }

    .info-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-top: 20px;
    }

    .info-item {
        background: rgba(0, 30, 60, 0.6);
        padding: 15px;
        border-radius: 8px;
        border: 1px solid rgba(0, 255, 255, 0.2);
    }

    </style>
</head>
<body>
    <div class="scanline"></div>
    <div class="container">
        <header>
            <h1>量子模拟空间</h1>
            <div id="info"><strong>环境：</strong><span id="scene_desc"></span></div>
        </header>
        
        <div class="controls">
            <div class="control-group">
                <label for="steps_limit">步数限制:</label>
                <input type="number" id="steps_limit" value="20" min="1" max="100">
            </div>
            
            <div class="control-group">
                <label for="use_llm_sim">
                    <input type="checkbox" id="use_llm_sim" {% if data.use_llm %}checked{% endif %}> LLM驱动
                </label>
            </div>
            
            <button id="stepBtn">单步执行</button>
            <button id="playBtn">启动</button>
            <button id="pauseBtn">暂停</button>
            <button id="speedBtn">时序: 1x</button>
             <button id="resetBtn">重置</button>  <!-- 添加这个按钮 -->
            <button id="resimulateBtn">重新模拟</button>
        </div>
                <!-- 新增：导演信息面板 -->
        <div class="data-panel" id="director-panel" >
            <h2>导演日志</h2>
            <div class="data-card">
                <h3>当前剧情</h3>
                <p id="narrative-summary">等待导演就绪...</p>
            </div>
            <div class="data-card">
                <h3>计划进度</h3>
                <p id="plan-progress">等待计划...</p>
            </div>
        </div>
        
        <!-- 添加大纲显示区域 -->
        <div class="data-panel">
            <h2>故事大纲</h2>
            <div class="outline-container">
                <div class="outline-section">
                    <h3>主题：{{ data.outline.theme or '探索与发现' }}</h3>
                    <p><strong>主要冲突：</strong> {{ data.outline.main_conflict or '寻找真相' }}</p>
                </div>
                
                <div class="outline-section">
                    <h3>关键事件</h3>
                    <div class="events-timeline">
                        {% if data.outline.key_events %}
                            {% for event in data.outline.key_events[:10] %}
                            <div class="event-item" data-step="{{ event.step }}">
                                <span class="step-number">步骤 {{ event.step }}</span>
                                <span class="event-type">{{ event.event_type }}</span>
                                <p class="event-description">{{ event.description }}</p>
                                <div class="event-details">
                                    <strong>参与者：</strong> {{ event.participants|join(', ') }}<br>
                                    <strong>位置：</strong> {{ event.location }}<br>
                                    <strong>影响：</strong> {{ event.impact }}
                                </div>
                            </div>
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
                
                <div class="outline-section">
                    <h3>地图结构</h3>
                    <div class="map-structure">
                        {% if data.scene.structure.rooms %}
                            {% for room in data.scene.structure.rooms %}
                            <div class="room-info">
                                <h4>{{ room.name }}</h4>
                                <p>{{ room.description }}</p>
                                <div class="room-details">
                                    <strong>尺寸：</strong> {{ room.width }}x{{ room.height }}<br>
                                    <strong>位置：</strong> ({{ room.x }}, {{ room.y }})<br>
                                    <strong>连接：</strong> {{ room.connections|join(', ') }}<br>
                                    <strong>特殊特征：</strong> {{ room.special_features|join(', ') }}
                                </div>
                            </div>
                            {% endfor %}
                        {% endif %}
                    </div>
                </div>
            </div>
        </div>
                <!-- 添加进度条容器 -->
        <div class="progress-container">
            <div class="progress-bar">
                <div id="progress" class="progress"></div>
            </div>
            <div class="progress-text">
                <span id="progress-text">0 / 20 步</span>
            </div>
        </div>
              
        <div class="stage-container">
        <div id="map-container" style="position: absolute; left:0; top:0; width: 100%;; height:600px; z-index:0;"></div>
        <div id="stage" style="position: absolute; left:0; top:0; width: 100%;; height:600px; z-index:2;"></div>
        </div>
        <div class="data-panel">
            <div class="tabs">
                <div class="tab active" onclick="showTab('scene')">环境</div>
                <div class="tab" onclick="showTab('agents')">智能体</div>
                <div class="tab" onclick="showTab('timeline')">时序</div>
            </div>
            
            <div id="scene" class="tab-content active">
                <div class="data-card">
                    <h3>环境参数</h3>
                    <p><strong>类型:</strong> {{ data.scene.type }}</p>
                    <p><strong>描述:</strong> {{ data.scene.description }}</p>
                </div>
            </div>
            
            <div id="agents" class="tab-content">
                <div class="data-grid">
                    {% for agent in data.agents %}
                    <div class="data-card">
                        <h3>智能体 {{ agent.name }}</h3>
                        <p><strong>ID:</strong> {{ agent.id }}</p>
                        <p><strong>性格矩阵:</strong> {{ agent.personality|join(', ') }}</p>
                        <p><strong>目标向量:</strong> {{ agent.goal }}</p>
                        <p><strong>初始坐标:</strong> ({{ agent.x }}, {{ agent.y }})</p>
                        <p><strong>信号频率:</strong> <span style="display:inline-block;width:20px;height:20px;background:{{ agent.color }};border-radius:50%;vertical-align:middle;"></span> {{ agent.color }}</p>
                    </div>
                    {% endfor %}
                </div>
            </div>
            
            <div id="timeline" class="tab-content">
                <div class="timeline-container">
                    <div id="timeline-events"></div>
                </div>
            </div>
        </div>
        
        <div style="text-align: center; margin-top: 30px;">
            <a href="/" class="back-link">← 返回控制中心</a>
        </div>
    </div>
    
    <script>
        const DATA = {{ data|tojson }};
        const CONFIG = DATA.config;
        const STORY_NAME = "{{ story_name }}";
        const stage = document.getElementById('stage');
        const mapContainer = document.getElementById('map-container');
        const sceneDesc = document.getElementById('scene_desc');
        const stepBtn = document.getElementById('stepBtn');
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const resetBtn = document.getElementById('resetBtn') || null; // 添加 || null
        if (resetBtn) {
            resetBtn.addEventListener('click', resetTimeline);
        }
        const speedBtn = document.getElementById('speedBtn');
        const resimulateBtn = document.getElementById('resimulateBtn');
        const stepsLimitInput = document.getElementById('steps_limit');
        const progressBar = document.getElementById('progress');
        
        // 设置场景描述
        sceneDesc.textContent = DATA.scene.description + " (" + DATA.scene.type + ")";

        let currentStep = 0;
        let isPlaying = false;
        let playInterval;
        let speedMultiplier = 1;
        let agents = {};
        let timelineEvents = [];
        let currentNarrative = "等待导演就绪..."; // 新增

        // 地图渲染函数 - 完整版本
        function renderMap() {
            // 检查必要的元素和数据
            if (!mapContainer) {
                console.error('地图容器未找到');
                return;
            }
            
            if (!DATA || !DATA.scene || !DATA.scene.structure) {
                console.error('地图渲染失败：缺少必要数据');
                return;
            }
            
            const rooms = DATA.scene.structure.rooms || [];
            const paths = DATA.scene.structure.room_relationships || [];
            
            console.log('开始渲染地图，房间数量:', rooms.length, '路径数量:', paths.length);
            
            // 清除现有地图元素
            mapContainer.innerHTML = '';
            
            if (rooms.length === 0) {
                console.warn('没有房间数据');
                return;
            }
            
            // 计算地图的边界
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            rooms.forEach(room => {
                minX = Math.min(minX, room.x || 0);
                minY = Math.min(minY, room.y || 0);
                maxX = Math.max(maxX, (room.x || 0) + (room.width || 120));
                maxY = Math.max(maxY, (room.y || 0) + (room.height || 100));
            });
            
            // 获取容器的实际尺寸
            const containerRect = mapContainer.getBoundingClientRect();
            const containerWidth = containerRect.width;
            const containerHeight = 600; // 保持固定高度
            const padding = 50;
            
            // 计算地图的实际尺寸
            const mapWidth = maxX - minX;
            const mapHeight = maxY - minY;
            
            // 计算缩放比例
            const scaleX = (containerWidth - padding * 2) / mapWidth;
            const scaleY = (containerHeight - padding * 2) / mapHeight;
            const scale = Math.min(scaleX, scaleY, 1.5); // 限制最大缩放比例
            
            // 计算偏移量，使地图居中
            const offsetX = (containerWidth - mapWidth * scale) / 2 - minX * scale;
            const offsetY = (containerHeight - mapHeight * scale) / 2 - minY * scale;
            
            // 创建房间元素数组，用于后续路径计算
            const roomElements = [];
            
            // 渲染房间
            rooms.forEach((room, index) => {
                const roomElement = document.createElement('div');
                roomElement.className = 'room-element';
                roomElement.dataset.roomId = room.id || `room_${index}`;
                
                // 计算房间的实际位置和尺寸
                const roomX = (room.x || 0) * scale + offsetX;
                const roomY = (room.y || 0) * scale + offsetY;
                const roomWidth = (room.width || 120) * scale;
                const roomHeight = (room.height || 100) * scale;
                
                // 为不同房间设置不同的颜色主题
                const roomColors = [
                    'rgba(0, 150, 255, 0.7)', // 蓝色
                    'rgba(255, 100, 0, 0.7)',  // 橙色
                    'rgba(0, 255, 150, 0.7)',  // 青色
                    'rgba(255, 0, 150, 0.7)',  // 粉色
                    'rgba(150, 0, 255, 0.7)',  // 紫色
                    'rgba(255, 255, 0, 0.6)',  // 黄色
                    'rgba(0, 255, 255, 0.6)'   // 青绿色
                ];
                const roomColor = roomColors[index % roomColors.length];
                
                // 设置房间样式
                roomElement.style.cssText = `
                    position: absolute;
                    left: ${roomX}px;
                    top: ${roomY}px;
                    width: ${roomWidth}px;
                    height: ${roomHeight}px;
                    border: 3px solid rgba(0, 255, 255, 0.9);
                    background: linear-gradient(135deg, ${roomColor}, rgba(0, 120, 200, 0.5));
                    border-radius: 12px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: #ffffff;
                    font-size: ${Math.max(12, 14 * scale)}px;
                    font-weight: bold;
                    z-index: 1;
                    box-shadow: 
                        0 0 20px rgba(0, 255, 255, 0.6),
                        inset 0 0 20px rgba(0, 255, 255, 0.2),
                        0 0 40px rgba(0, 150, 255, 0.4);
                    transition: all 0.3s ease;
                    cursor: pointer;
                    overflow: hidden;
                    animation: roomGlow 3s ease-in-out infinite alternate;
                    animation-delay: ${index * 0.2}s;
                `;
                
                // 添加房间名称
                const roomName = document.createElement('div');
                roomName.textContent = room.name || `房间 ${index + 1}`;
                roomName.style.cssText = `
                    text-align: center;
                    padding: 8px;
                    word-wrap: break-word;
                    max-width: 100%;
                    text-shadow: 0 0 10px rgba(0, 0, 0, 0.8);
                    z-index: 2;
                    pointer-events: none;
                `;
                roomElement.appendChild(roomName);
                
                // 添加房间内部装饰
                const decoration = document.createElement('div');
                decoration.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.2) 0%, transparent 50%);
                    pointer-events: none;
                `;
                roomElement.appendChild(decoration);
                
                // 添加房间状态指示器
                const statusIndicator = document.createElement('div');
                statusIndicator.style.cssText = `
                    position: absolute;
                    top: 8px;
                    right: 8px;
                    width: 12px;
                    height: 12px;
                    background: radial-gradient(circle, rgba(0, 255, 0, 0.8) 0%, rgba(0, 255, 0, 0.3) 100%);
                    border-radius: 50%;
                    box-shadow: 0 0 10px rgba(0, 255, 0, 0.6);
                    animation: statusPulse 2s ease-in-out infinite;
                    pointer-events: none;
                `;
                roomElement.appendChild(statusIndicator);
                
                // 添加悬停效果
                roomElement.addEventListener('mouseenter', function() {
                    this.style.background = `linear-gradient(135deg, ${roomColor}, rgba(0, 180, 255, 0.7))`;
                    this.style.borderColor = 'rgba(255, 255, 0, 0.9)';
                    this.style.transform = 'scale(1.03)';
                    this.style.zIndex = '5';
                });
                
                roomElement.addEventListener('mouseleave', function() {
                    this.style.background = `linear-gradient(135deg, ${roomColor}, rgba(0, 120, 200, 0.5))`;
                    this.style.borderColor = 'rgba(0, 255, 255, 0.9)';
                    this.style.transform = 'scale(1)';
                    this.style.zIndex = '1';
                });
                
                // 添加点击事件
                roomElement.addEventListener('click', function() {
                    console.log(`点击了房间: ${room.name || '房间 ' + (index + 1)}`);
                    showRoomInfo(room, index);
                });
                
                // 添加到地图容器
                mapContainer.appendChild(roomElement);
                
                // 保存房间元素信息
                roomElements.push({
                    element: roomElement,
                    room: room,
                    index: index,
                    x: roomX,
                    y: roomY,
                    width: roomWidth,
                    height: roomHeight
                });
            });
            
            // 延迟渲染路径，确保房间元素已经完全创建和定位
            setTimeout(() => {
                renderPaths(roomElements, paths);
            }, 150);
            
            // 保存缩放信息和房间元素信息
            window.mapScale = scale;
            window.mapOffsetX = offsetX;
            window.mapOffsetY = offsetY;
            window.roomElements = roomElements;
            
            console.log('地图渲染完成，缩放比例:', scale, '偏移量:', { offsetX, offsetY });
        }

        // 渲染路径的辅助函数
        function renderPaths(roomElements, paths) {
            console.log('开始渲染路径...');
            
            // 清除现有路径
            const existingPaths = mapContainer.querySelectorAll('.path-group');
            existingPaths.forEach(path => path.remove());
            
            // 重置路径缓存
            window.renderedPaths = new Set();
            
            let pathIndex = 0;
            
            // 渲染显式路径
            if (paths && paths.length > 0) {
                console.log('渲染显式路径，数量:', paths.length);
                paths.forEach((path, index) => {
                    const fromRoomElement = roomElements.find(r => r.room.id === path.from);
                    const toRoomElement = roomElements.find(r => r.room.id === path.to);
                    
                    if (fromRoomElement && toRoomElement) {
                        renderPath(fromRoomElement, toRoomElement, path, pathIndex++);
                    } else {
                        console.warn(`路径 ${index} 找不到对应的房间:`, path);
                    }
                });
            } else {
                // 使用房间的连接关系渲染路径
                console.log('使用房间连接关系渲染路径');
                roomElements.forEach((roomData, index) => {
                    const room = roomData.room;
                    if (room.connections && room.connections.length > 0) {
                        room.connections.forEach(connectionId => {
                            const connectedRoomData = roomElements.find(r => r.room.id === connectionId);
                            if (connectedRoomData) {
                                // 避免重复渲染同一条路径
                                const pathKey = [room.id, connectedRoomData.room.id].sort().join('-');
                                if (!window.renderedPaths.has(pathKey)) {
                                    window.renderedPaths.add(pathKey);
                                    renderPath(roomData, connectedRoomData, { 
                                        connection_type: 'door',
                                        from: room.id,
                                        to: connectionId
                                    }, pathIndex++);
                                }
                            }
                        });
                    }
                });
            }
            
            console.log('路径渲染完成，总数:', pathIndex);
        }
                // 添加路径更新函数，用于窗口大小改变时重新计算路径
        function updateAllPaths() {
            // 清除现有路径
            const existingPaths = mapContainer.querySelectorAll('.path-group');
            existingPaths.forEach(path => path.remove());
            
            // 重置路径缓存
            window.renderedPaths = new Set();
            
            // 重新渲染所有路径
            const rooms = DATA.scene.structure.rooms || [];
            const paths = DATA.scene.structure.room_relationships || [];
            
            if (paths && paths.length > 0) {
                paths.forEach((path, index) => {
                    const fromRoom = rooms.find(r => r.id === path.from);
                    const toRoom = rooms.find(r => r.id === path.to);
                    
                    if (fromRoom && toRoom) {
                        renderPath(fromRoom, toRoom, path, index);
                    }
                });
            } else {
                rooms.forEach((room, index) => {
                    if (room.connections && room.connections.length > 0) {
                        room.connections.forEach((connectionId, connIndex) => {
                            const connectedRoom = rooms.find(r => r.id === connectionId);
                            if (connectedRoom) {
                                const pathKey = [room.id, connectedRoom.id].sort().join('-');
                                if (!window.renderedPaths.has(pathKey)) {
                                    window.renderedPaths.add(pathKey);
                                    renderPath(room, connectedRoom, { connection_type: 'door' }, index + connIndex);
                                }
                            }
                        });
                    }
                });
            }
        }

        // 添加窗口大小改变监听器
        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(() => {
                updateAllPaths();
            }, 250);
        });

        // 渲染路径函数 - 重写版本
        function renderPath(fromRoom, toRoom, pathData, index) {
            try {
                // 确保地图容器存在
                if (!mapContainer) {
                    console.error('地图容器不存在，无法渲染路径');
                    return;
                }
                
                // 获取实际的房间元素
                const fromRoomElement = mapContainer.querySelector(`[data-room-id="${fromRoom.id}"]`) ||
                                    mapContainer.querySelector(`[data-room-id="${fromRoom.id || 'room_0'}"]`);
                
                const toRoomElement = mapContainer.querySelector(`[data-room-id="${toRoom.id}"]`) ||
                                    mapContainer.querySelector(`[data-room-id="${toRoom.id || 'room_0'}"]`);
                
                if (!fromRoomElement || !toRoomElement) {
                    console.warn('无法找到房间元素，跳过路径渲染');
                    return;
                }
                
                // 获取房间元素的实际位置和尺寸
                const fromRect = fromRoomElement.getBoundingClientRect();
                const toRect = toRoomElement.getBoundingClientRect();
                const containerRect = mapContainer.getBoundingClientRect();
                
                // 计算相对于地图容器的坐标
                const fromX = fromRect.left - containerRect.left + fromRect.width / 2;
                const fromY = fromRect.top - containerRect.top + fromRect.height / 2;
                const toX = toRect.left - containerRect.left + toRect.width / 2;
                const toY = toRect.top - containerRect.top + toRect.height / 2;
                
                // 计算连线的长度和角度
                const deltaX = toX - fromX;
                const deltaY = toY - fromY;
                const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                
                // 创建路径组容器
                const pathGroup = document.createElement('div');
                pathGroup.className = 'path-group';
                pathGroup.dataset.pathId = `path_${index}`;
                pathGroup.style.cssText = `
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    pointer-events: none;
                    z-index: 0;
                `;
                
                // 创建主路径线
                const pathElement = document.createElement('div');
                pathElement.className = 'path-element';
                pathElement.style.cssText = `
                    position: absolute;
                    left: ${fromX}px;
                    top: ${fromY}px;
                    width: ${length}px;
                    height: 5px;
                    background: linear-gradient(90deg, 
                        rgba(255, 100, 0, 0.9) 0%, 
                        rgba(255, 200, 0, 0.7) 25%,
                        rgba(255, 255, 0, 0.8) 50%,
                        rgba(255, 200, 0, 0.7) 75%,
                        rgba(255, 100, 0, 0.9) 100%);
                    transform-origin: 0 50%;
                    transform: rotate(${angle}deg);
                    z-index: 1;
                    box-shadow: 
                        0 0 15px rgba(255, 200, 0, 0.8),
                        0 0 30px rgba(255, 150, 0, 0.6);
                    animation: pathPulse 2s ease-in-out infinite;
                    animation-delay: ${index * 0.3}s;
                `;
                
                // 创建起点端点
                const fromPoint = document.createElement('div');
                fromPoint.className = 'path-point path-point-start';
                fromPoint.style.cssText = `
                    position: absolute;
                    left: ${fromX - 8}px;
                    top: ${fromY - 8}px;
                    width: 16px;
                    height: 16px;
                    background: radial-gradient(circle, rgba(255, 255, 0, 1) 0%, rgba(255, 200, 0, 0.8) 100%);
                    border-radius: 50%;
                    z-index: 3;
                    box-shadow: 
                        0 0 20px rgba(255, 255, 0, 0.9),
                        0 0 40px rgba(255, 200, 0, 0.7);
                    animation: pointPulse 1.5s ease-in-out infinite;
                    animation-delay: ${index * 0.3}s;
                `;
                
                // 创建终点端点
                const toPoint = document.createElement('div');
                toPoint.className = 'path-point path-point-end';
                toPoint.style.cssText = `
                    position: absolute;
                    left: ${toX - 8}px;
                    top: ${toY - 8}px;
                    width: 16px;
                    height: 16px;
                    background: radial-gradient(circle, rgba(255, 100, 0, 1) 0%, rgba(255, 50, 0, 0.8) 100%);
                    border-radius: 50%;
                    z-index: 3;
                    box-shadow: 
                        0 0 20px rgba(255, 100, 0, 0.9),
                        0 0 40px rgba(255, 50, 0, 0.7);
                    animation: pointPulse 1.5s ease-in-out infinite 0.5s;
                    animation-delay: ${index * 0.3 + 0.5}s;
                `;
                
                // 添加所有元素到路径组
                pathGroup.appendChild(pathElement);
                pathGroup.appendChild(fromPoint);
                pathGroup.appendChild(toPoint);
                
                // 添加到地图容器
                mapContainer.appendChild(pathGroup);
                
                // 添加交互效果
                pathGroup.addEventListener('mouseenter', function() {
                    pathElement.style.height = '8px';
                    pathElement.style.filter = 'brightness(1.3)';
                    fromPoint.style.transform = 'scale(1.5)';
                    toPoint.style.transform = 'scale(1.5)';
                });
                
                pathGroup.addEventListener('mouseleave', function() {
                    pathElement.style.height = '5px';
                    pathElement.style.filter = 'brightness(1)';
                    fromPoint.style.transform = 'scale(1)';
                    toPoint.style.transform = 'scale(1)';
                });
                
                console.log(`路径 ${index} 渲染完成: ${fromRoom.name || '房间'} -> ${toRoom.name || '房间'}`);
            } catch (error) {
                console.error('渲染路径时出错:', error);
            }
        }





        // 智能体渲染函数
        // 智能体渲染函数
        function renderAgents() {
            if (!stage) {
                console.error('舞台容器未找到');
                return;
            }
            
            stage.innerHTML = '';
            agents = {};
            
            if (!DATA.agents || DATA.agents.length === 0) {
                console.warn('没有智能体数据');
                return;
            }
            
            console.log('开始渲染智能体，数量:', DATA.agents.length);
            
            DATA.agents.forEach((a, index) => {
                const agentElement = document.createElement('div');
                agentElement.className = 'agent';
                agentElement.dataset.agentId = a.id || index;
                
                // 确保智能体有位置
                let agentX = a.x || 500;
                let agentY = a.y || 300;
                
                // 使用地图缩放
                const scale = window.mapScale || 1;
                const offsetX = window.mapOffsetX || 0;
                const offsetY = window.mapOffsetY || 0;
                
                const scaledX = agentX * scale + offsetX;
                const scaledY = agentY * scale + offsetY;
                
                const agentSize = Math.max(40, 50 * scale);
                
                agentElement.style.cssText = `
                    position: absolute;
                    left: ${scaledX - agentSize/2}px;
                    top: ${scaledY - agentSize/2}px;
                    width: ${agentSize}px;
                    height: ${agentSize}px;
                    background: ${a.color || '#' + Math.floor(Math.random()*16777215).toString(16)};
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: #000;
                    font-weight: bold;
                    font-size: ${Math.max(14, 18 * scale)}px;
                    z-index: 10;
                    box-shadow: 
                        0 0 30px currentColor,
                        0 0 60px currentColor,
                        0 0 90px currentColor;
                    transition: all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                    cursor: pointer;
                    animation: agentFloat 3s ease-in-out infinite;
                    animation-delay: ${index * 0.4}s;
                `;
                
                agentElement.textContent = (a.name || `A${index + 1}`).charAt(0).toUpperCase();
                
                // 添加智能体光晕效果
                const glow = document.createElement('div');
                glow.style.cssText = `
                    position: absolute;
                    width: 100%;
                    height: 100%;
                    border-radius: 50%;
                    background: radial-gradient(circle, rgba(255, 255, 255, 0.4) 0%, transparent 70%);
                    animation: agentRipple 2s ease-out infinite;
                    pointer-events: none;
                `;
                agentElement.appendChild(glow);
                
                // 添加智能体标签
                const label = document.createElement('div');
                label.style.cssText = `
                    position: absolute;
                    top: -25px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 20, 40, 0.9);
                    color: #00ffff;
                    padding: 4px 8px;
                    border-radius: 4px;
                    font-size: ${Math.max(10, 12 * scale)}px;
                    white-space: nowrap;
                    border: 1px solid rgba(0, 255, 255, 0.5);
                    z-index: 15;
                `;
                label.textContent = a.name || `Agent ${index + 1}`;
                agentElement.appendChild(label);
                
                // 添加悬停效果
                agentElement.addEventListener('mouseenter', function() {
                    this.style.transform = 'scale(1.3) translateY(-5px)';
                    this.style.zIndex = '100';
                });
                
                agentElement.addEventListener('mouseleave', function() {
                    this.style.transform = 'scale(1) translateY(0)';
                    this.style.zIndex = '10';
                });
                
                stage.appendChild(agentElement);
                agents[a.id || index] = { 
                    el: agentElement, 
                    x: agentX,
                    y: agentY
                };
            });
            
            console.log('智能体渲染完成');
        }

                // 更新智能体位置和状态
        function updateAgentPosition(agentUpdate) {
            if (!agentUpdate || agentUpdate.agent_id === undefined) {
                console.warn('智能体更新数据无效');
                return;
            }
            
            const agentId = agentUpdate.agent_id;
            const agent = agents[agentId];
            
            if (!agent) {
                console.warn('未找到智能体:', agentId);
                return;
            }
            
            // 更新位置 - 使用平滑过渡
            if (agentUpdate.position) {
                const scale = window.mapScale || 1;
                const offsetX = window.mapOffsetX || 0;
                const offsetY = window.mapOffsetY || 0;
                
                const scaledX = agentUpdate.position.x * scale + offsetX;
                const scaledY = agentUpdate.position.y * scale + offsetY;
                const agentSize = parseFloat(agent.el.style.width);
                
                // 使用 CSS transition 实现平滑移动
                agent.el.style.left = (scaledX - agentSize/2) + 'px';
                agent.el.style.top = (scaledY - agentSize/2) + 'px';
                
                // 保存新位置
                agent.x = agentUpdate.position.x;
                agent.y = agentUpdate.position.y;
                
                // 添加移动特效
                addMoveEffect(scaledX, scaledY);
            }
            
            // 显示对话气泡
            if (agentUpdate.action && agentUpdate.action.dialogue) {
                showAgentDialogue(agentId, agentUpdate.action.dialogue);
            }
            
            // 更新状态
            updateAgentStatus(agentId, agentUpdate);
        }

        // 添加移动特效
        function addMoveEffect(x, y) {
            const effect = document.createElement('div');
            effect.style.cssText = `
                position: absolute;
                left: ${x - 15}px;
                top: ${y - 15}px;
                width: 30px;
                height: 30px;
                border-radius: 50%;
                border: 2px solid rgba(0, 255, 255, 0.8);
                background: radial-gradient(circle, rgba(0, 255, 255, 0.3) 0%, transparent 70%);
                pointer-events: none;
                z-index: 5;
                animation: moveEffect 1s ease-out forwards;
            `;
            
            // 添加动画
            const style = document.createElement('style');
            style.textContent = `
                @keyframes moveEffect {
                    0% {
                        transform: scale(0.5);
                        opacity: 1;
                    }
                    100% {
                        transform: scale(2);
                        opacity: 0;
                    }
                }
            `;
            document.head.appendChild(style);
            
            stage.appendChild(effect);
            
            // 动画结束后移除元素
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }

        // 显示智能体对话
        function showAgentDialogue(agentId, dialogue) {
            const agent = agents[agentId];
            if (!agent) return;
            
            // 创建或获取气泡
            let bubble = agent.el.querySelector('.bubble');
            if (!bubble) {
                bubble = document.createElement('div');
                bubble.className = 'bubble';
                bubble.style.cssText = `
                    position: absolute;
                    bottom: 60px;
                    left: 50%;
                    transform: translateX(-50%);
                    min-width: 120px;
                    max-width: 250px;
                    background: rgba(0, 20, 40, 0.95);
                    border: 2px solid rgba(0, 255, 255, 0.8);
                    color: #00ffff;
                    padding: 10px 15px;
                    border-radius: 10px;
                    font-size: 12px;
                    z-index: 20;
                    box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                
                // 添加气泡尾巴
                const tail = document.createElement('div');
                tail.style.cssText = `
                    position: absolute;
                    bottom: -10px;
                    left: 20px;
                    border-width: 10px 10px 0;
                    border-style: solid;
                    border-color: rgba(0, 255, 255, 0.8) transparent;
                `;
                bubble.appendChild(tail);
                
                agent.el.appendChild(bubble);
            }
            
            // 设置对话内容
            bubble.textContent = dialogue;
            bubble.style.opacity = '1';
            
            // 3秒后淡出
            setTimeout(() => {
                bubble.style.opacity = '0';
            }, 3000);
        }



        function updateAgentStatus(agentId, agentUpdate) {
            const statusElement = document.getElementById(`agent-status-${agentId}`);
            if (statusElement) {
                statusElement.innerHTML = `
                    <strong>心情:</strong> ${agentUpdate.mood || 'neutral'}<br>
                    <strong>能量:</strong> ${agentUpdate.energy || 100}<br>
                    <strong>位置:</strong> (${agentUpdate.position ? agentUpdate.position.x : 'N/A'}, ${agentUpdate.position ? agentUpdate.position.y : 'N/A'})
                `;
            }
        }

        // 添加时间线事件
        function addTimelineEvent(stepData) {
            const eventContainer = document.getElementById('timeline-events');
            const eventElement = document.createElement('div');
            eventElement.className = 'timeline-item';
            
            const agentName = stepData.agent_update ? 
                (DATA.agents[stepData.agent_update.agent_id] ? DATA.agents[stepData.agent_update.agent_id].name : 'Unknown') : 
                'Unknown';
            
            eventElement.innerHTML = `
                <h3>步骤 ${stepData.step}</h3>
                <p><strong>执行单元:</strong> ${agentName}</p>
                <p><strong>行动:</strong> ${stepData.agent_update.action ? stepData.agent_update.action.action_type : 'Unknown'}</p>
                <p><strong>位置:</strong> (${stepData.agent_update.position ? stepData.agent_update.position.x : 'N/A'}, ${stepData.agent_update.position ? stepData.agent_update.position.y : 'N/A'})</p>
                ${stepData.agent_update.action && stepData.agent_update.action.dialogue ? `<p><strong>对话:</strong> ${stepData.agent_update.action.dialogue}</p>` : ''}
            `;
            
            eventContainer.insertBefore(eventElement, eventContainer.firstChild);
            
            // 限制显示的事件数量
            while (eventContainer.children.length > 10) {
                eventContainer.removeChild(eventContainer.lastChild);
            }
        }

        // 高亮当前事件
        function highlightCurrentEvent(step) {
            document.querySelectorAll('.event-item').forEach(item => {
                item.classList.remove('active');
            });
            
            const currentEvent = document.querySelector(`.event-item[data-step="${step}"]`);
            if (currentEvent) {
                currentEvent.classList.add('active');
                currentEvent.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }

        // 更新进度条
        function updateProgress() {
            const stepsLimit = parseInt(stepsLimitInput.value);
            const progress = (currentStep / stepsLimit) * 100;
            progressBar.style.width = progress + '%';
        }

        // 执行单步
        /**
 * 执行单步模拟
 * 这个函数现在处理两种情况：
 * 1. 手动点击“单步执行”。
 * 2. 自动播放模式下，由 playInterval 调用。
 * 它会持续请求后端，直到一个完整的“导演计划”执行完毕。
 */
        // 在 simulation.html 中修改API调用

// 确保所有API调用使用正确的URL
function executeStep() {
    if (stepBtn.disabled) {
        return;
    }

    stepBtn.disabled = true;
    stepBtn.textContent = '执行中...';

    fetch('/api/simulate_step', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify({
            story_name: STORY_NAME
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            const stepData = data.data;
            currentStep = stepData.step;
            updateDisplay(stepData);
            highlightCurrentEvent(currentStep);

            const stepsLimit = parseInt(stepsLimitInput.value);
            if (currentStep >= stepsLimit) {
                pauseTimeline();
                showNotification('模拟完成！', 'success');
            } else {
                if (isPlaying && stepData.status === 'running' && 
                    stepData.plan_progress && !stepData.plan_progress.endsWith('/1')) {
                    setTimeout(executeStep, 100);
                }
            }
        } else {
            showNotification('执行失败: ' + (data.message || '未知错误'), 'error');
            if (isPlaying) {
                pauseTimeline();
            }
        }
    })
    .catch(error => {
        console.error('执行失败:', error);
        showNotification('执行失败: ' + error.message, 'error');
        if (isPlaying) {
            pauseTimeline();
        }
    })
    .finally(() => {
        if (!isPlaying || (data && data.data && data.data.plan_progress && 
            data.data.plan_progress.endsWith('/1'))) {
            stepBtn.disabled = false;
            stepBtn.textContent = '单步执行';
        }
    });
}



        // 更新显示
        function updateDisplay(stepData) {
        if (stepData.agent_update) {
            updateAgentPosition(stepData.agent_update);
        }
        
        // 更新导演面板
        updateDirectorPanel(stepData);

        addTimelineEvent(stepData);
        updateProgress();
        }
        function updateDirectorPanel(stepData) {
        const directorPanel = document.getElementById('director-panel');
        const narrativeSummary = document.getElementById('narrative-summary');
        const planProgress = document.getElementById('plan-progress');

        // 确保面板可见
        directorPanel.style.display = 'block';

        // 这里我们假设后端会返回 narrative_summary
        // 如果没有，我们可以根据action生成一个简单的描述
        if (stepData.narrative_summary) {
            currentNarrative = stepData.narrative_summary;
        } else if (stepData.agent_update && stepData.agent_update.action) {
            const action = stepData.agent_update.action;
            const agentName = DATA.agents[stepData.agent_update.agent_id].name;
            currentNarrative = `${agentName} 正在执行 "${action.action_type}"。`;
        }
        
        narrativeSummary.textContent = currentNarrative;
        planProgress.textContent = stepData.plan_progress || '计算中...';
    }

    // 新增：处理Agent卡片点击事件
    function setupAgentCardListeners() {
        const agentCards = document.querySelectorAll('#agents .data-card');
        agentCards.forEach(card => {
            card.style.cursor = 'pointer'; // 鼠标悬停时显示手型
            card.addEventListener('click', function() {
                // 从卡片中提取agent ID
                const agentIdText = this.querySelector('p').textContent;
                const agentId = parseInt(agentIdText.match(/ID:\s*(\d+)/)[1]);
                showAgentModal(agentId);
            });
        });
    }

    // 新增：显示Agent详情弹窗
    // 修改 showAgentModal 函数
function showAgentModal(agentId) {
    const modal = document.getElementById('agent-modal');
    const modalName = document.getElementById('modal-agent-name');
    const modalBody = document.getElementById('modal-agent-body');

    // 显示加载状态
    modalName.textContent = '加载中...';
    modalBody.innerHTML = '<p>正在获取智能体状态...</p>';
    modal.style.display = 'block';

    // 从后端获取最新的agent状态
    fetch('/api/simulate_step', { 
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
            story_name: STORY_NAME, 
            get_state_only: true 
        })
    })
    .then(response => {
        console.log('响应状态:', response.status);
        console.log('响应头:', response.headers);
        
        if (!response.ok) {
            // 如果响应不是200，尝试获取错误信息
            return response.text().then(text => {
                console.error('服务器返回错误:', text);
                throw new Error(`HTTP ${response.status}: ${text}`);
            });
        }
        
        // 检查响应内容类型
        const contentType = response.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            return response.json();
        } else {
            return response.text().then(text => {
                console.error('非JSON响应:', text);
                throw new Error('服务器返回了非JSON响应');
            });
        }
    })
    .then(data => {
        if (data.status === 'success') {
            const agentState = data.current_state.agent_states.find(a => a.id === agentId);
            if (agentState) {
                modalName.textContent = `${agentState.name} (ID:${agentState.id})`;
                
                let bodyHTML = `
                    <p><strong>性格:</strong> ${agentState.personality.join(', ')}</p>
                    <p><strong>目标:</strong> ${agentState.goal}</p>
                    <p><strong>当前位置:</strong> (${agentState.position.x},${agentState.position.y})</p>
                    <p><strong>所在房间:</strong> ${agentState.current_room || '未知'}</p>
                    <p><strong>心情:</strong> ${agentState.mood}</p>
                    <p><strong>能量:</strong> ${agentState.energy}</p>
                    <p><strong>物品:</strong> ${agentState.inventory.length > 0 ? agentState.inventory.join(', ') : '无'}</p>
                `;
                
                // 记忆和关系
                const memoryList = agentState.memory.length > 0 ? 
                    agentState.memory.map(m => `- ${m.content}`).join('<br>') : '无';
                const relationshipList = Object.keys(agentState.relationships).length > 0 ? 
                    Object.entries(agentState.relationships).map(([id, val]) => `- Agent ${id}:${val}`).join('<br>') : '无';

                bodyHTML += `
                    <div class="info-grid">
                        <div class="info-item">
                            <h4>最近记忆</h4>
                            <p>${memoryList}</p>
                        </div>
                        <div class="info-item">
                            <h4>人际关系</h4>
                            <p>${relationshipList}</p>
                        </div>
                    </div>
                `;
                
                modalBody.innerHTML = bodyHTML;
            } else {
                modalName.textContent = '错误';
                modalBody.innerHTML = '<p>未找到指定的智能体</p>';
            }
        } else {
            modalName.textContent = '错误';
            modalBody.innerHTML = `<p>获取状态失败: ${data.message}</p>`;
        }
    })
    .catch(error => {
        console.error('获取智能体状态失败:', error);
        modalName.textContent = '错误';
        modalBody.innerHTML = `
            <p>获取智能体状态失败</p>
            <p><strong>错误信息:</strong> ${error.message}</p>
            <button onclick="showAgentModal(${agentId})" style="margin-top: 10px; padding: 5px 10px;">重试</button>
        `;
    });
}

    // 点击弹窗外部关闭
    window.onclick = function(event) {
        const modal = document.getElementById('agent-modal');
        if (event.target == modal) {
            modal.style.display = 'none';
        }
    }


        // 播放时间线
        function playTimeline() {
            const stepsLimit = parseInt(stepsLimitInput.value);
            if (currentStep >= stepsLimit) {
                pauseTimeline();
                showNotification('模拟完成！', 'success');
                return;
            }
            
            executeStep();
        }

        // 暂停播放
        function pauseTimeline() {
            isPlaying = false;
            clearInterval(playInterval);
            playBtn.textContent = '启动';
        }

        // 重置动画
        function resetTimeline() {
            pauseTimeline();
            currentStep = 0;
            progressBar.style.width = '0%';
            document.getElementById('timeline-events').innerHTML = '';
            renderMap();
            renderAgents();
        }

        // 重新模拟
        function resimulate() {
            const stepsLimit = parseInt(stepsLimitInput.value);
            const useLLM = document.getElementById('use_llm_sim').checked;
            
            resimulateBtn.disabled = true;
            resimulateBtn.textContent = '模拟中...';
            
            fetch('/api/simulate_with_llm', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    story_name: STORY_NAME,
                    steps: stepsLimit,
                    use_llm: useLLM
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    // 更新数据
                    DATA.agents = data.data.agents;
                    DATA.scene = data.data.scene;
                    DATA.outline = data.data.outline;
                    
                    resetTimeline();
                    showNotification('重新模拟完成', 'success');
                } else {
                    showNotification('模拟失败: ' + (data.message || '未知错误'), 'error');
                }
            })
            .catch(error => {
                console.error('模拟失败:', error);
                showNotification('模拟失败: ' + error.message, 'error');
            })
            .finally(() => {
                resimulateBtn.disabled = false;
                resimulateBtn.textContent = '重新模拟';
            });
        }

        // 通知函数
        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            notification.style.background = type === 'success' ? 
                'linear-gradient(45deg, rgba(0, 255, 136, 0.9), rgba(0, 255, 255, 0.9))' : 
                'linear-gradient(45deg, rgba(255, 0, 0, 0.9), rgba(255, 100, 0, 0.9))';
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.padding = '20px 30px';
            notification.style.borderRadius = '10px';
            notification.style.boxShadow = '0 8px 25px rgba(0, 255, 255, 0.4)';
            notification.style.transform = 'translateX(150%)';
            notification.style.transition = 'transform 0.3s ease';
            notification.style.zIndex = '1000';
            notification.style.fontWeight = '700';
            notification.style.textTransform = 'uppercase';
            notification.style.letterSpacing = '1px';
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            setTimeout(() => {
                notification.style.transform = 'translateX(150%)';
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // 事件监听器
        stepBtn.addEventListener('click', executeStep);
        
        playBtn.addEventListener('click', () => {
            if (!isPlaying) {
                isPlaying = true;
                playBtn.textContent = '运行中';
                playInterval = setInterval(playTimeline, 1000 / speedMultiplier);
            }
        });
        
        pauseBtn.addEventListener('click', pauseTimeline);
        resetBtn.addEventListener('click', resetTimeline);
        resimulateBtn.addEventListener('click', resimulate);
        
        speedBtn.addEventListener('click', () => {
            const speeds = [0.5, 1, 2, 4];
            const currentIndex = speeds.indexOf(speedMultiplier);
            speedMultiplier = speeds[(currentIndex + 1) % speeds.length];
            speedBtn.textContent = `时序: ${speedMultiplier}x`;
            
            // 如果正在播放，重新设置间隔
            if (isPlaying) {
                clearInterval(playInterval);
                playInterval = setInterval(playTimeline, 1000 / speedMultiplier);
            }
        });
        
        // 标签页切换
        function showTab(tabName) {
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(tab => tab.classList.remove('active'));
            
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => tab.classList.remove('active'));
            
            document.getElementById(tabName).classList.add('active');
            event.target.classList.add('active');
        }

        // 创建粒子效果
        function createParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 800 + 'px';
            particle.style.top = Math.random() * 540 + 'px';
            particle.style.opacity = Math.random() * 0.8 + 0.2;
            stage.appendChild(particle);
            
            const duration = Math.random() * 3000 + 2000;
            const startTime = Date.now();
            
            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = elapsed / duration;
                
                if (progress < 1) {
                    particle.style.opacity = (1 - progress) * 0.8;
                    particle.style.transform = `translateY(${progress * 100}px)`;
                    requestAnimationFrame(animate);
                } else {
                    stage.removeChild(particle);
                }
            }
            
            animate();
        }
    // ==================== 页面初始化 ====================
    // 放在所有函数定义之后
    document.addEventListener('DOMContentLoaded', function() {
            console.log('页面加载完成，开始初始化...');
            
            // 添加模态框关闭按钮事件监听
            const closeBtn = document.querySelector('.close-btn');
            if (closeBtn) {
                closeBtn.addEventListener('click', function() {
                    document.getElementById('agent-modal').style.display = 'none';
                });
            } else {
                console.error('未找到模态框关闭按钮');
            }
            
            // 检查必要的元素是否存在
            if (!mapContainer) {
                console.error('地图容器未找到');
                return;
            }
            
            if (!stage) {
                console.error('舞台容器未找到');
                return;
            }
            
            // 延迟初始化确保所有资源加载完成
            setTimeout(() => {
                try {
                    console.log('开始渲染地图...');
                    renderMap();
                    
                    console.log('开始渲染智能体...');
                    renderAgents();
                    setupAgentCardListeners();

                    console.log('初始化完成');
                    
                    // 显示欢迎通知
                    showNotification('AI小镇模拟系统已就绪', 'success');
                    
                } catch (error) {
                    console.error('初始化过程中发生错误:', error);
                    showNotification('初始化失败: ' + error.message, 'error');
                }
            }, 300); // 增加延迟时间确保完全加载
        });

    </script>
</body>
<!-- 在 <body> 标签末尾，添加弹窗HTML结构 -->
<div id="agent-modal" class="modal">
    <div class="modal-content">
        <span class="close-btn">&times;</span>
        <h2 id="modal-agent-name">智能体详情</h2>
        <div id="modal-agent-body">
            <!-- 详细信息将通过JS动态填充 -->
        </div>
    </div>
</div>
</html>
